import roslib
roslib.load_manifest('joint_position')
import rospy

#for keyboard mapper
import termios
import tty
import sys

#for ctrl-c
import signal

#for joystick mapper
from sensor_msgs.msg import Joy

class Mapper(object):
    """ Interface class to map an input device to a controller
    """


    def __init__(self, controller):
        """ set up the ctrl-c handler for this input device
        Args:
            controller
        """
        self._controller = controller
        self._done = False
        signal.signal(signal.SIGINT, self._handle_ctrl_c)

    def _handle_ctrl_c(self, signum, frame):
        """ ctrl-c handler
        """
        self.stop()

    def stop(self):
        self._done = True

    def done(self):
        return self._done

    def loop(self):
        """ Virtual loop function
            function that loops while mapping
            input to control. Should end when self.done is True
        """
        raise NotImplementedError()






class KeyboardMapper(Mapper):
    """ class that listens to keypresses and sends associated robot joint commands """

    def __init__(self, controller):
        super(KeyboardMapper, self).__init__(controller)
        self._mode = 0
        self._done = False
        jcf = self._create_command_function

        # these deltas should be some pct of the range from the URDF
        # it would be nice if the whole mapping could be autogenerated from the URDF
        self._bindings = {
            #     mode 0: all left     mode 1: all right     mode 2: top l&r       mode 3: bottom l&r
            'a': [jcf('left_s0',+0.1), jcf('right_s0',+0.1), jcf('right_s0',+0.1), jcf('right_e1',+0.1)],
            'f': [jcf('left_s0',-0.1), jcf('right_s0',-0.1), jcf('right_s0',-0.1), jcf('right_e1',-0.1)],
            's': [jcf('left_s1',+0.1), jcf('right_s1',+0.1), jcf('right_s1',+0.1), jcf('right_w0',+0.1)],
            'd': [jcf('left_s1',-0.1), jcf('right_s1',-0.1), jcf('right_s1',-0.1), jcf('right_w0',-0.1)],
            'w': [jcf('left_w0',+0.1), jcf('right_w0',+0.1), jcf('right_e0',+0.1), jcf('right_w1',+0.1)],
            'e': [jcf('left_w0',-0.1), jcf('right_w0',-0.1), jcf('right_e0',-0.1), jcf('right_w1',-0.1)],

            'h': [jcf('left_e0',+0.1), jcf('right_e0',+0.1), jcf('left_s0', +0.1), jcf('left_e1', +0.1)],
            'l': [jcf('left_e0',-0.1), jcf('right_e0',-0.1), jcf('left_s0', -0.1), jcf('left_e1', -0.1)],
            'j': [jcf('left_e1',+0.1), jcf('right_e1',+0.1), jcf('left_s1', +0.1), jcf('left_w0', +0.1)],
            'k': [jcf('left_e1',-0.1), jcf('right_e1',-0.1), jcf('left_s1', -0.1), jcf('left_w0', -0.1)],
            'u': [jcf('left_w1',+0.1), jcf('right_w1',+0.1), jcf('left_e0', +0.1), jcf('left_w1', +0.1)],
            'i': [jcf('left_w1',-0.1), jcf('right_w1',-0.1), jcf('left_e0', -0.1), jcf('left_w1', -0.1)],

            'r': [jcf('left_w2',+0.1), jcf('right_w2',+0.1), jcf('right_w2',+0.1), jcf('right_w2',-0.1)],
            'y': [jcf('left_w2',-0.1), jcf('right_w2',-0.1), jcf('left_w2', +0.1), jcf('left_w2', -0.1)],

            'o': [jcf('left_gripper', 1.0)],
            '0': [jcf('left_gripper', 0.0)],
            'q': [jcf('right_gripper', 1.0)],
            '1': [jcf('right_gripper', 0.0)],

            'g': [self._incmode],
            ';': [self._decmode],
            '?': [self.show_help],
            '\x1b': [self.stop], #Escape... doesn't print.
        }

        self.show_help()

    def stop(self):
        """ Esc: stop """
        self._done = True

    def _create_command_function(self, jointName, delta):
        """create a function to increment a specific joint by a specific delta"""
        def commandFunction():
            try:
                self._controller.command({jointName: delta})
            except OSError:
                print("joint %s not found; is the robot running?" % (jointName,))
        commandFunction.__doc__ = "modify " + jointName + " by " + str(delta)
        return commandFunction

    def _getch(self):
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        except:
            raise OSError
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch

    def _incmode(self):
        """increment mode: switch key bindings"""
        self._mode += 1

    def _decmode(self):
        """decrement mode: switch key bindings"""
        self._mode -= 1

    def show_help(self):
        """show binding help"""
        print "============ bindings for current mode " + str(self._mode) + " =================="
        for key, cmds in sorted(self._bindings.items()):
            i = self._mode % len(cmds)
            print "    " + str(key) + ": " + str(cmds[i].__doc__)

    def _exec_binding(self,c):
        if c in self._bindings:
            cmds = self._bindings[c]
            i = self._mode % len(cmds)
            print(cmds[i].__doc__)
            cmds[i]()
        else:
            print("unknown key: " + c)
            print("press '?' for help")

    def loop(self):
        self._done = False
        self._mode = 0
        while not self.done():
            c = self._getch()
            self._exec_binding(c)






class JoystickMapper(Mapper):
    """ Maps joystick input to robot control
    """


    def __init__(self, controller, padType):
        """ Maps joystick input to robot control
        Sets up the bindings
        Args:
            controller(BaxterController): a type of Baxter robot controller
            padType(str): the type of controller used ('xbox' or 'logitech')
        """
        super(JoystickMapper, self).__init__(controller)
        self.padType = padType
        self._sub = rospy.Subscriber("/joy", Joy, self._incoming)
        self._controls = {}
        self._newData = False
        self._setupBindings()

    def _setupBindings(self):
        """ private function to setup the bindings
        from generic joystick to robot command
        """
        class _ButtonTransition(object):
            """ local class to monitor transitions
            The transition is measured when read
            """
            def __init__(self, controls, name, downVal=1, upVal=0):
                self._controls = controls
                self._name = name
                self._value = upVal
                self._downVal = downVal
                self._upVal = upVal
            def changed(self):
                if self._name in self._controls:
                    newValue = self._controls[self._name]
                equal = (newValue == self._value)
                self._value = newValue
                return not equal
            def down(self):
                if (self.changed() and (self._value == self._downVal)):
                    print ("button %s pressed" % (self._name))
                    return True
                return False
            def up(self):
                return (self.changed() and (self._value == self._upVal))

        def _create_button_changed_dict(*buttonNames):
            """ Creates a dictionary holding the transition
            objects  for each button
            """
            btnDict = {}
            for name in buttonNames:
                btnDict[name] = _ButtonTransition(self._controls,name)
            return btnDict

        class _JointSelector(object):
            """ Local class to maintain a selection of
            joints to control depending on the control mode
            """
            def __init__(self, *joints):
                self.joints = joints
                self.index = 0
            def inc(self):
                self.index = (self.index+1) % len(self.joints)
                print("selected %s" % (self.joints[self.index]))
            def dec(self):
                self.index = (self.index-1) % len(self.joints)
                print("selected %s" % (self.joints[self.index]))
            def get(self, offset=0):
                return self.joints[(self.index+offset)%len(self.joints)]

        buttons = _create_button_changed_dict('rightBumper', 'leftBumper', 'function1', 'function2', 'leftTrigger', 'rightTrigger', 'btnDown', 'btnLeft', 'btnRight')
        left_selector = _JointSelector('left_s0','left_s1','left_e0','left_e1','left_w0', 'left_w1', 'left_w2')
        right_selector = _JointSelector('right_s0','right_s1','right_e0','right_e1','right_w0', 'right_w1', 'right_w2')

        def create_trans_function(transitions, function, useRetVal = False):
            def f(controlName):
                if transitions[controlName].down():
                    retVal = function()
                    if useRetVal:
                        return retVal
                return (None, None)#to appease caller expecting a tuple
            return f

        def create_command_function(selector, offset, scale):
            """ function to create a command function
            Create a function to execute a specific control command
            Args:
                selector(JointSelector):holds joint names to control
                offset(int): modify which joint selector.get returns
                scale(float): scale factor for the command
            Returns: a function to control a specific joint
            """
            def f(controlName):
                """ function to control a specific joint
                Args:
                    controlName(str): the name of a an input control to
                    read, scale and store in a tupel
                Returns:
                    a tuple containing a joint name and an associated
                    command value
                """
                return (selector.get(offset), self._controls[controlName] * scale)
            return f

        self.bindings = {
            'function1':  create_trans_function(buttons, self.stop),
            'function2':  create_trans_function(buttons, self.stop),
            'rightBumper':  create_trans_function(buttons, left_selector.inc),
            'rightTrigger': create_trans_function(buttons, left_selector.dec),
            'leftBumper':   create_trans_function(buttons, right_selector.inc),
            'leftTrigger':  create_trans_function(buttons, right_selector.dec),
            'rightStickHorz': create_command_function(left_selector,0,-1),
            'rightStickVert': create_command_function(left_selector,1,-1),
            'leftStickHorz':  create_command_function(right_selector,0,-1),
            'leftStickVert':  create_command_function(right_selector,1,-1),
            'btnLeft':  create_trans_function(buttons, self._grip_left, True),
            'btnRight':  create_trans_function(buttons, self._grip_right, True),
        }

    def _grip_left(self):
        """ ugly helper for gripping """
        if self._controller.gripperRight.position > 50.0:
            return ('right_gripper',0.0)
        else:
            return ('right_gripper',100.0)

    def _grip_right(self):
        """ ugly helper for gripping """
        if self._controller.gripperLeft.position > 50.0:
            return ('left_gripper',0.0)
        else:
            return ('left_gripper',100.0)

    def _incoming(self, msg):
        """ callback for messages from joystick input
        Args:
              msg(Joy): a joystick input message
        """
        def deadband(axis,size):
            """ Local function to create a deadband
            Args:
                axis(float): the value of the to-be-deadbanded axis
                size(float): the size of the deadband
            Returns:
                the deadbanded value of the axis
            """
            if axis > size or axis < -size:
                return axis
            return 0

        if self.padType == "xbox":
            self._controls['btnLeft'] = (msg.buttons[2] == 1)
            self._controls['btnUp'] = (msg.buttons[3] == 1)
            self._controls['btnDown'] = (msg.buttons[0] == 1)
            self._controls['btnRight'] = (msg.buttons[1] == 1)

            self._controls['dPadUp'] = (msg.axes[7] > 0.5)
            self._controls['dPadDown'] = (msg.axes[7] < -0.5)
            self._controls['dPadLeft'] = (msg.axes[6] > 0.5)
            self._controls['dPadRight'] = (msg.axes[6] < -0.5)

            self._controls['leftStickHorz'] = deadband(msg.axes[0],0.1)
            self._controls['leftStickVert'] = deadband(msg.axes[1],0.1)
            self._controls['rightStickHorz'] = deadband(msg.axes[3],0.1)
            self._controls['rightStickVert'] = deadband(msg.axes[4],0.1)

            self._controls['leftBumper'] = (msg.buttons[4] == 1)
            self._controls['rightBumper'] = (msg.buttons[5] == 1)
            self._controls['leftTrigger'] = (msg.axes[2] > 0.5)
            self._controls['rightTrigger'] = (msg.axes[5] > 0.5)

            self._controls['function1'] = (msg.buttons[6] == 1)
            self._controls['function2'] = (msg.buttons[10] == 1)

        elif self.padType == "logitech":
            self._controls['btnLeft'] = (msg.buttons[0] == 1)
            self._controls['btnUp'] = (msg.buttons[3] == 1)
            self._controls['btnDown'] = (msg.buttons[1] == 1)
            self._controls['btnRight'] = (msg.buttons[2] == 1)

            self._controls['dPadUp'] = (msg.axes[5] > 0.5)
            self._controls['dPadDown'] = (msg.axes[5] < -0.5)
            self._controls['dPadLeft'] = (msg.axes[4] > 0.5)
            self._controls['dPadRight'] = (msg.axes[4] < -0.5)

            self._controls['leftStickHorz'] = deadband(msg.axes[0],0.1)
            self._controls['leftStickVert'] = deadband(msg.axes[1],0.1)
            self._controls['rightStickHorz'] = deadband(msg.axes[2],0.1)
            self._controls['rightStickVert'] = deadband(msg.axes[3],0.1)

            self._controls['leftBumper'] = (msg.buttons[4] == 1)
            self._controls['rightBumper'] = (msg.buttons[5] == 1)
            self._controls['leftTrigger'] = (msg.buttons[6] == 1)
            self._controls['rightTrigger'] = (msg.buttons[7] == 1)

            self._controls['function1'] = (msg.buttons[8] == 1)
            self._controls['function2'] = (msg.buttons[9] == 1)
        else:
            print("no bindings for joystick type %s" % self.padType)
            self._done = True
            raise OSError(EINVAL, "unknown padType")
        self._newData = True

    def loop(self):
        """ loops to translate joystick input into robot control
        """
        self._done = False
        print("listening for joystick commands")
        while not self.done():
            if self._newData:
                commands = {}
                for controlName, controlFunction in self.bindings.items():
                    (joint_name, joint_pos) = controlFunction(controlName)
                    """ control functions do not need to yield a command, and
                    thus can leave joint_name 'None' to simply be executed
                    """
                    if joint_name:
                          commands[joint_name] = joint_pos
                self._controller.command(commands)

class FileMapper(Mapper):
    """ CSV File mapper
    Maps input read from a csv file to robot control
    """

    def __init__(self, controller, filename, loops):
        """ Maps csv file input to robot control
        Args:
            controller(BaxterController): a type of Baxter robot controller
            filename(str): path to csv file to read from
            loops(int): number of times to play back the file
        """
        super(FileMapper, self).__init__(controller)
        self.filename = filename
        self._start_time = rospy.Time.now()
        self._loops = loops

    def _time_stamp(self):
        diff = rospy.Time.now() - self._start_time
        return diff.to_sec()

    def loop(self):
        self._done = False
        if self._loops == 0:
            while(not self.done()):
                self.play_file()
        elif self._loops > 0:
            for i in range(self._loops):
                self.play_file()
        else:
            self.play_file()

    def play_file(self):
        """ Loops through csv file
        Does not loop indefinitely, but only until the file is read
        and processed. Reads each line, split up in columns and
        formats each line into a controller command in the form of
        name/value pairs. Names come from the column headers
        first column is the time stamp
        """
        rate = rospy.Rate(1000)
        print("playing back %s" % (self.filename,))
        with open(self.filename, 'r') as f:
            lines = f.readlines()
        keys = lines[0].rstrip().split(',')
        for values in lines[1:]:
            print(values)
            def convert(x):
                try:
                    return float(x)
                except ValueError:
                    return None
            #convert the line of strings to a float or None
            values = [convert(x) for x in values.rstrip().split(',')]
            #zip the values with the joint names
            combined = zip(keys[1:], values[1:])
            #take out any tuples that have a none value
            cleaned = [x for x in combined if x[1] is not None]
            #convert it to a dictionary with only valid commands
            cmd = dict(cleaned)
            #command this set of commands until the next frame
            while (self._time_stamp() < values[0] and not self.done()):
                self._controller.command(cmd, False)
                rate.sleep()



